# 以太网驱动移植文件

## 一、背景

- rt-smart的`imx6ull-artpi-smart`BSP包（以下简称`ull`）对应的板子使用的网络硬件和mx6Ul不同
- 芯片上，`ull`使用的是LAN8720，`ul`使用的是KSZ8080
- 连线上，`ull`的RESET管脚直接和MCU管脚连接，而`ul`的RESET管脚通过串转并芯片`SN74HC595`连接

## 二、解决思路

- NXP官方的`imx6ul-evk`的硬件连接和`ul`相同
- 可以参考`uboot-imx`代码

## 三、实现

#### 3.1重启实现

由于重启管脚连接到了串转并电路，因此首先需要实现串转并的驱动或者功能以供调用

##### 3.1.1串转并驱动

###### Step1管脚复用设置

将控制串转并的四个管脚设置为GPIO，在`fsl_enet.c`中实现，代码如下

```c
    /*设置串转并管脚*/
    RT_IOMUXC_SetPinMux(IOMUXC_SNVS_BOOT_MODE0_GPIO5_IO10, 0U);
    RT_IOMUXC_SetPinConfig(IOMUXC_SNVS_BOOT_MODE0_GPIO5_IO10,
                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
                        IOMUXC_SW_PAD_CTL_PAD_SPEED(2U) |
                        IOMUXC_SW_PAD_CTL_PAD_PKE_MASK |
                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
    RT_IOMUXC_SetPinMux(IOMUXC_SNVS_BOOT_MODE1_GPIO5_IO11, 0U);
    RT_IOMUXC_SetPinConfig(IOMUXC_SNVS_BOOT_MODE1_GPIO5_IO11,
                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
                        IOMUXC_SW_PAD_CTL_PAD_SPEED(2U) |
                        IOMUXC_SW_PAD_CTL_PAD_PKE_MASK |
                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
    RT_IOMUXC_SetPinMux(IOMUXC_SNVS_SNVS_TAMPER7_GPIO5_IO07, 0U);
    RT_IOMUXC_SetPinConfig(IOMUXC_SNVS_SNVS_TAMPER7_GPIO5_IO07,
                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
                        IOMUXC_SW_PAD_CTL_PAD_SPEED(2U) |
                        IOMUXC_SW_PAD_CTL_PAD_PKE_MASK |
                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
    RT_IOMUXC_SetPinMux(IOMUXC_SNVS_SNVS_TAMPER8_GPIO5_IO08, 0U);
    RT_IOMUXC_SetPinConfig(IOMUXC_SNVS_SNVS_TAMPER8_GPIO5_IO08,
                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
                        IOMUXC_SW_PAD_CTL_PAD_SPEED(2U) |
                        IOMUXC_SW_PAD_CTL_PAD_PKE_MASK |
                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
    /*串转并管脚设置end*/
```

###### Step2 管脚方向设置及重启设置

在`fsl_phy.c`的`phy_reset()`函数中实现，代码如下

```c
enum qn {
	HDMI_NRST,
	ENET1_NRST,
	ENET2_NRST,
	CAN1_2_STBY,
	BT_NPWD,
	CSI_RST,
	CSI_PWDN,
	LCD_NPWREN,
};

enum qn_func {
	qn_reset,
	qn_enable,
	qn_disable,
};

enum qn_level {
	qn_low = 0,
	qn_high = 1,
};

static enum qn_level seq[3][2] = {
	{0, 1}, {1, 1}, {0, 0}
};

static enum qn_func qn_output[8] = {
	qn_reset, qn_reset, qn_reset, qn_enable, qn_disable, qn_reset,
	qn_disable, qn_disable
};

#define IOX_STCP_PIN 7
#define IOX_OE_PIN 8
#define IOX_SDI_PIN 10
#define IOX_SHCP_PIN 11

static void iox74lv_init(void)
{
	int i;
    GPIO_Type *gpio_base = NULL;
    gpio_pin_config_t sw_config =
    {
        kGPIO_DigitalOutput,
        0,
        kGPIO_NoIntmode,
    };
    /*获取GPIO5寄存器基地址*/
    gpio_base = (GPIO_Type *)rt_ioremap((void *)PHY_SW_GPIO,0x1000);
    /*设置相关引脚为输出*/
    GPIO_PinInit(gpio_base, IOX_STCP_PIN, &sw_config);
    GPIO_PinInit(gpio_base, IOX_OE_PIN, &sw_config);
    GPIO_PinInit(gpio_base, IOX_SDI_PIN, &sw_config);
    GPIO_PinInit(gpio_base, IOX_SHCP_PIN, &sw_config);
    /*设置OE输出低电平*/
    GPIO_WritePinOutput(gpio_base, IOX_OE_PIN, 0);

	for (i = 7; i >= 0; i--) {
        /*设置SHCP输出低电平*/
        GPIO_WritePinOutput(gpio_base, IOX_SHCP_PIN, 0);
		/*设置SDI输出低电平*/
        GPIO_WritePinOutput(gpio_base, IOX_SDI_PIN, seq[qn_output[i]][0]);
		rt_thread_delay(50);
        /*设置SHCP输出高电平*/
        GPIO_WritePinOutput(gpio_base, IOX_SHCP_PIN, 1);
		rt_thread_delay(50);
	}
    /*设置STCP输出低电平*/
    GPIO_WritePinOutput(gpio_base, IOX_STCP_PIN, 0);
	rt_thread_delay(50);
	/*
	 * shift register will be output to pins
	 */
    /*设置STCP输出高电平*/
    GPIO_WritePinOutput(gpio_base, IOX_STCP_PIN, 1);

	for (i = 7; i >= 0; i--) {
        /*设置SHCP输出低电平*/
        GPIO_WritePinOutput(gpio_base, IOX_SHCP_PIN, 0);
        /*设置SDI输出低电平*/
        GPIO_WritePinOutput(gpio_base, IOX_SDI_PIN, seq[qn_output[i]][1]);
		rt_thread_delay(50);
        /*设置SHCP输出高电平*/
        GPIO_WritePinOutput(gpio_base, IOX_SHCP_PIN, 1);
		rt_thread_delay(50);
	}
    /*设置STCP输出低电平*/
    GPIO_WritePinOutput(gpio_base, IOX_STCP_PIN, 0);
	rt_thread_delay(50);
	/*
	 * shift register will be output to pins
	 */
    /*设置STCP输出高电平*/
    GPIO_WritePinOutput(gpio_base, IOX_STCP_PIN, 1);
}

status_t phy_reset()
{
    iox74lv_init();
    return kStatus_Success;
}
```

由于PHY的重启前需要定义好管脚，因此调整`drv_eth.c中rt_imx6ul_eth_init()`函数调用的顺序

```c
    ENET_InitPins();
    phy_reset();
```

STEP4 时钟频率设置

修改`drv_eth.c中ENET_InitModuleClock()`函数，注释掉的是原代码

```c
void ENET_InitModuleClock(void)
{
    /*const clock_enet_pll_config_t config = {true, true, false, 1, 1};*/
    const clock_enet_pll_config_t config = {false, true, false, 0, 0};
    CLOCK_InitEnetPll(&config);
}
```

## 四、调试记录

wireshark抓包记录

0000-255255255255的DHCP的包

以及一个ICMPV6的包

Ping指令可以正常发出ARP，目标主机也回复了ARP，但是没有接收

速率 双工设置是否一致

是否开启了自动关闭

ping函数使用的是`netdev.c中的netdev_cmd_ping`函数，再调用`lwip-2.1.2`下的`ethernetif.c`中的`lwip_netdev_ping`函数

再调用`ping.c`的`lwip_ping_recv`函数， 再调用`sockets.c中的lwip_recvfrom`函数

创建负责接收的socket的类型不是TCP，也不是UDP，也不是IPV6，而是Raw connection

###### netdev.c函数

创建socket，类型RAW，协议ICMP

```c
    /* new a socket */
    if ((s = lwip_socket(AF_INET, SOCK_RAW, IP_PROTO_ICMP)) < 0)
    {
        return -RT_ERROR;
    }
```

部分调试记录见rtthread论坛的发帖记录：https://club.rt-thread.org/ask/question/434275.html

2022-1-12问题梳理

- ARP可以正确解析
- ICMP不能正确解析，出现协议、数据包头的解析错误

###### 设置为10M全双工试试

1. 设置PHY为10M全双工
2. 设置MAC控制器RCR寄存器

## 五、移植总结

#### 5.1管脚定义

定义相关管脚

#### 5.2 时钟初始化

###### 选择时钟

![image-20220110092231763](image-20220110092231763.png)

![image-20220110092421079](image-20220110092421079.png)

![image-20220110100144833](image-20220110100144833.png)

![image-20220110100051549](image-20220110100051549.png)

```
void CLOCK_InitEnetPll(const clock_enet_pll_config_t *config)
{
    uint32_t enet_pll = CCM_ANALOG_PLL_ENET_ENET1_DIV_SELECT(config->loopDivider1) |
                        CCM_ANALOG_PLL_ENET_ENET0_DIV_SELECT(config->loopDivider0);

    if (config->enableClkOutput0)
    {
        enet_pll |= CCM_ANALOG_PLL_ENET_ENET1_125M_EN_MASK;
    }

    if (config->enableClkOutput1)
    {
        enet_pll |= CCM_ANALOG_PLL_ENET_ENET2_125M_EN_MASK;
    }

    if (config->enableClkOutput2)
    {
        enet_pll |= CCM_ANALOG_PLL_ENET_ENET_25M_REF_EN_MASK;
    }

    CCM_ANALOG->PLL_ENET = enet_pll;

    /* Wait for stable */
    while ((CCM_ANALOG->PLL_ENET & CCM_ANALOG_PLL_ENET_LOCK_MASK) == 0)
    {
    }
}

typedef struct _clock_enet_pll_config
{
    bool     enableClkOutput0;  /*!< Power on and enable PLL clock output for ENET0 (ref_enetpll0). */
    bool     enableClkOutput1;  /*!< Power on and enable PLL clock output for ENET1 (ref_enetpll1). */
    bool     enableClkOutput2;  /*!< Power on and enable PLL clock output for ENET2 (ref_enetpll2). */
    uint8_t  loopDivider0;      /*!< Controls the frequency of the ENET0 reference clock.
                                     b00 25MHz
                                     b01 50MHz
                                     b10 100MHz (not 50% duty cycle)
                                     b11 125MHz */
    uint8_t  loopDivider1;      /*!< Controls the frequency of the ENET1 reference clock.
                                     b00 25MHz
                                     b01 50MHz
                                     b10 100MHz (not 50% duty cycle)
                                     b11 125MHz */
} clock_enet_pll_config_t;
```

需要说明的是，系统有三个ENET时钟，ref_enetpll0~ref_enetpll2，分别对应三个ENET模块，实际上，CPU只有两个ENET模块，因此ref_enetpll2是没有被使用的。其中

- ref_enetpll0、ref_enetpll1的输入时钟为125MHz，输出可选25/50/100/125MHz
- ref_enetpll2固定输出25MHz

设置ENET_EN使能，设置ENET_DIV_SELECT选择频率

在本例中，使用ref_enetpll1的50MHz输出

###### 使能时钟

设置GPR->GPR1寄存器，DIR设置为1使能，SEL设置为0，方向为输出

![image-20220110093839642](image-20220110093839642.png)

```c
    IOMUXC_GPR_Type *GPR1 = (IOMUXC_GPR_Type *)rt_ioremap((void *)IOMUXC_GPR,0x1000);
    reg_value = GPR1->GPR1;
    reg_value &= ~(IOMUXC_GPR_GPR1_ENET2_CLK_SEL_MASK
                 | IOMUXC_GPR_GPR1_ENET2_CLK_SEL_MASK);
    reg_value |=  IOMUXC_GPR_GPR1_ENET2_TX_CLK_DIR(1);
    reg_value |=  IOMUXC_GPR_GPR1_ENET2_CLK_SEL(0);
```

#### 5.3 PHY初始化

初始化PHY需要对应PHY电路的PHY address

###### PHY Manage Interface初始化即功能设计

也被称为Serial Manager Interface（SMI）， 即和PHY通信的接口

初始化分为两部分：管脚初始化、控制寄存器初始化；其中管脚为

- MDC：时钟
- MDIO：数据

管理寄存器为MSCR，需要设置时钟频率、输出电平Hold Time、是否禁止preamble

![image-20220110105820846](image-20220110105820846.png)

其中时钟频率的设置如上图，ENET的IPS bus即为AHB bus。MDC时钟的值需要等于或者稍微小于2.5MHz。

功能设计包括PHY_Write、PHY_Read，主要是操作MMFR寄存器，由于这是标准化操作，可以直接使用通用代码。

###### 读取PHY ID并验证

```c
    while ((idReg != PHY_CONTROL_ID1) && (counter != 0))
    {
        PHY_Read(base, phyAddr, PHY_ID1_REG, &idReg);
        counter --;       
    }

    if (!counter)
    {
        return kStatus_Fail;
    }
```

###### PHY软重启

设置PHY芯片的相关寄存器（basic control），重启PHY

```c
PHY_Write(base, phyAddr, PHY_BASICCONTROL_REG, PHY_BCTL_RESET_MASK);
```

###### 设置PHY频率

在本例中，PHY的频率由系统的`ENET2_TCK`管脚提供，为50MHz

```c
    uint32_t data = 0;
    result = PHY_Read(base, phyAddr, PHY_CONTROL2_REG, &data);
    if ( result != kStatus_Success)
    {
        return result;
    }
    result = PHY_Write(base, phyAddr, PHY_CONTROL2_REG, (data | PHY_CTL2_REFCLK_SELECT_MASK));
    if (result != kStatus_Success)
    {
        return result;
    }
```

需要说明的是，网络的传输速度和传输模式（全/半双工）不是通过PHY寄存器设置的，而是通过上电时相关管脚的电平高低设置的，具体见PHY芯片的数据手册

###### 判断PHY状态

读取PHY的basic status寄存器，判断是否Link Up

如果连接成功，进入下一步

#### 5.4 ENET初始化

###### 重启系统的ENET模块

设置ENET的ECR寄存器RESET位，重启模块

```c
static inline void ENET_Reset(ENET_Type *base)
{
    base->ECR |= ENET_ECR_RESET_MASK;
}
```

###### 设置ENET模块RCR寄存器

- 设置ENET工作在MII还是RMII模式
- 设置传输速度

###### 设置ENET模块TCR寄存器

- 设置全双工/半双工

###### 设置缓存相关寄存器

TFWR、RSFL、MRBR等

###### 设置Mac地址

###### 使能中断

###### 使能ENET

设置ECR寄存器使能位

###### 设置中断服务函数

###### 使能接收

###### 使能系统中断

## 六、ARP协议学习

#### 作用

Address Resolution Protocol，地址解析协议，沟通IP地址与MAC地址的作用

可以根据IP查MAC，不能根据MAC查IP

#### 报文结构（28Bytes）

以太网首部（14Bytes，不属于ARP报文）

- 以太网目的地址：6Bytes
- 以太网源地址：6Bytes
- 帧类型：2bytes（806代表ARP）

APR报文（28Bytes）

- 硬件类型：2
- 协议类型：2
- 地址长度：1
- 协议长度：1
- op：2（Request、Reply）
- 发送段以太网地址：6
- 发送端IP地址：4
- 目的以太网地址：6
- 目的IP地址：4
- 

